Первоначально необходимо спроектировать базу данных, чтобы потом понимать какой должен быть запрос, и какой ответ.
В силу имеющегося опыта работы с СУБД PostgreSQL, было принято использовать её для хранения данных. 

Так как необходимо была обработать два эндпоинта appointments, где у таблицы appointments должна быть уникальная пара doctor_id и start_time, то стало понятно,
что помимо таблицы appointments должна быть и таблица врачей (doctors), на id записи в которой должен ссылаться внешним ключом столбец doctor_id в таблице appointments.
Так как доктор является человеком, было предпринято создать базовые простые столбцы для идентификации: 
ФИО (name с текстовым типом) с простой валидацией (ограничение длины до 150 символов) и Дата рождения(birth_date с типом DATE), 
а также по умолчанию автоинкрементальный первичный ключ id целочисленного типа данных.

Далее таблица appointments. В тестовом задании указано, что у данной таблицы должны присутствоать столбцы doctor_id и start_time. 
Также дополнительно были добавлены первичный ключ id аналогично id в таблице doctors, и базово описание приема записи к врачу. 
Так как doctor_id является внешним ключом к столбцу id в таблице doctors, он тоже должен быть целочисленного типа. 
Так как пара doctor_id и start_time должны иметь уникальную связь, start_time помимо времени приема к врачу должен также хранить и дату, 
так как в разные дни врач может иметь запись на прием в одно и тоже время, в силу чего было решено указать тип данных timestamp without timezone.
Столбец name также является просто VARCHAR с ограничением в 3000 символов для достаточно большого описания текста.

Теперь можно приступать к реализации. Первоначально было принято решение инициализировать взаимодействие с базой данных. 
По документации FastAPI (https://fastapi.tiangolo.com/tutorial/sql-databases/) было принято решение использовать sqlmodel, 
содержащую как SQLAlchemy для взаимодействия с базой данных, так и Pydantic для создания моделей, использующих жесткую валидацию данных при HTTP запросах и ответах. 
Объединяя эти две зависимости, sqlmodel предоставляет возможность использовать Pydantic модели для ORM взаимодействия с базой данных через SQLAlchemy.

Согласно документации (https://fastapi.tiangolo.com/tutorial/bigger-applications/) был создан пакет app, а внутри него пакет db с модулями session.py, models.py и repository.py.
Изначально была описана логика models.py, в ней были две модели и описаны атрибуты согласно спроектированной базе данных.
Затем, согласно документации, описана логика подключения к БД в session.py.
В repository.py описана базовая функция создания таблиц в базе данных при запуске проекта (если в базе данных таблицы уже есть и в них есть данные, изменений не будет).

Далее необходимо спроектировать эндпоинты. В первую очередь необходимо понять, какие запросы нужно предоставить клиенту.
Согласно тестовому заданию требуется предоставить два эндпоинта - создание записи на прием к врачу, и получение информации о ней по её id.
Но так как для создания записи на прием к врачу в первую очередь необходимо создать доктора, который будет принимать пациента,
чтобы при создании записи на прием к врачу указывать корректный doctor_id. Тогда для этого нужно предоставить ещё два эндпоинта, создание доктора и, базово для проверки,
получения информации о докторе по его id.
Таким образом было принято решение реализовать 4 эндпоинта - создание доктора, получение информации о нем по id, создание записи на прием, получение информации о приеме по id.
Перед тем как реализовывать функции и логику эндпоинтов, необходимо спроектировать Pydantic модели, для валидации запросов от клиента и ответов.
В первую очередь нужно определить, какую информацию должен предоставлять клиент и какую он должен получать. Таким образом был создан пакет schemas, который содержит 
инициализированные Pydantic модели для докторов в doctors.py, и для записей на прием в appointments.py.
Теперь можно приступать к реализации логики эндпоинтов. Таким образом был создан пакет endpoints с реализованным эндпоинтами для докторов в doctors.py, и для записей на прием в appointments.py.
Так как методы SQLAlchemy, реализующие запросы в базу данных, для логики эндпоинтов являются довольно простыми и легковесными (не являлись транзакциями из нескольких запросов на изменение данных),
создание отдельных функций в repository.py не представилось необходимым. Также были определены и обработаны все возможные ошибки, которые Pydantic определить не сможет.

Для конфигурации строки подключения к основной базе данных PostgreSQL, а также для использования приложением тестовой базы данных при тестировании, необходимо спроектировать конфигурационный файл.
Первоначально необходимо определить, какие переменные для окружения необходимо предоставить разработчику при разворачивании для конфигурации, а какие не должны изменяться и всегда однозначны.
После этого была реализована логика, по которой формируется конфигурация подключения к базе данных как в тестовом режиме с тестовой бд, так и в основном режиме с PostgreSQL.
Был создан пакет core с модулем config.py.

После этого был создан согласно документации FastAPI, был создан основной исполнительный файл main.py и функция lifespan, в которой описана логика, которую необходимо реализовать при запуске приложения,
и при её остановке. Так как lifespan является простой функцией, она была вынесена отдельно в модуль utils.py в пакете core.

С учетом имеющейся логики эндпоинтов были созданы тесты. Создана папка tests и описана логика отправки всевозможных запросов и проверка о получении необходимых ответов.

После этого созданы и описаны файлы для деплоя (Dockerfile и docker-compose.yml). Выполнена проверка кода на black, isort, flake8 и mypy, код исправлен согласно полученным ошибкам.
Наконец, созданы файлы Makefile и ci/cd.
